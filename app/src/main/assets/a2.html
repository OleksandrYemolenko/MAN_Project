<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>MAXimal :: algo :: Поиск в ширину</title>
    <meta name="keywords" content="" />
    <meta name="description" content="" />
</head>

<body>
<div class="hTxt">
    <h1>Поиск в ширину</h1>
</div>

<main>
    <p>Поиск в ширину (обход в ширину, breadth-first search) — это один из основных алгоритмов на графах.</p>
    <p>В результате поиска в ширину находится путь кратчайшей длины в невзвешенном графе, т.е. путь, содержащий наименьшее число рёбер.</p>
    <p>Алгоритм работает за O (n+m), где n — число вершин, m — число рёбер.</p>

    <h1 >Описание алгоритма</h1>
    <ul>
        <li><h3>На вход алгоритма подаётся заданный граф (невзвешенный), и номер стартовой вершины s. Граф может быть как ориентированным, так и неориентированным, для алгоритма это не важно.</h3></li>
        <li><h3>Сам алгоритм можно понимать как процесс "поджигания" графа: на нулевом шаге поджигаем только вершину s. На каждом следующем шаге огонь с каждой уже горящей вершины перекидывается на всех её соседей; т.е. за одну итерацию алгоритма происходит расширение "кольца огня" в ширину на единицу (отсюда и название алгоритма).</h3></li>
        <li><h3>Более строго это можно представить следующим образом. Создадим очередь q, в которую будут помещаться горящие вершины, а также заведём булевский массив  used[], в котором для каждой вершины будем отмечать, горит она уже или нет (или иными словами, была ли она посещена).</h3></li>
        <li><h3>Изначально в очередь помещается только вершина s, и  used[s] = true, а для всех остальных вершин  used[] = false. Затем алгоритм представляет собой цикл: пока очередь не пуста, достать из её головы одну вершину, просмотреть все рёбра, исходящие из этой вершины, и если какие-то из просмотренных вершин ещё не горят, то поджечь их и поместить в конец очереди.</h3></li>
        <li><h3>В итоге, когда очередь опустеет, обход в ширину обойдёт все достижимые из s вершины, причём до каждой дойдёт кратчайшим путём. Также можно посчитать длины кратчайших путей (для чего просто надо завести массив длин путей d[]), и компактно сохранить информацию, достаточную для восстановления всех этих кратчайших путей (для этого надо завести массив "предков" p[], в котором для каждой вершины хранить номер вершины, по которой мы попали в эту вершину).</h3></li>
    </ul>
    <h1>Приложения алгоритма</h1>
    <ul>
        <li><h3>Поиск кратчайшего пути в невзвешенном графе.</h3></li>
        <li><h3>Поиск компонент связности в графе за O(n+m).</h3></li>
        <li><h3>Для этого мы просто запускаем обход в ширину от каждой вершины, за исключением вершин, оставшихся посещёнными used=true после предыдущих запусков. Таким образом, мы выполняем обычный запуск в ширину от каждой вершины, но не обнуляем каждый раз массив used[], за счёт чего мы каждый раз будем обходить новую компоненту связности, а суммарное время работы алгоритма составит по-прежнему O(n+m) (такие несколько запусков обхода на графе без обнуления массива used называются серией обходов в ширину).</h3></li>
        <li><h3>Нахождения решения какой-либо задачи (игры) с наименьшим числом ходов, если каждое состояние системы можно представить вершиной графа, а переходы из одного состояния в другое — рёбрами графа.</h3></li>
        <li><h3>Классический пример — игра, где робот двигается по полю, при этом он может передвигать ящики, находящиеся на этом же поле, и требуется за наименьшее число ходов передвинуть ящики в требуемые позиции. </h3></li>
        <li><h3>Решается это обходом в ширину по графу, где состоянием (вершиной) является набор координат: координаты робота, и координаты всех коробок.</h3></li>
        <li><h3>Нахождение кратчайшего пути в 0-1-графе (т.е. графе взвешенном, но с весами равными только 0 либо 1): достаточно немного модифицировать поиск в ширину: если текущее ребро нулевого веса, и происходит улучшение расстояния до какой-то вершины, то эту вершину добавляем не в конец, а в начало очереди.</h3></li>
        <li><h3>Нахождение кратчайшего цикла в ориентированном невзвешенном графе: производим поиск в ширину из каждой вершины; как только в процессе обхода мы пытаемся пойти из текущей вершины по какому-то ребру в уже посещённую вершину, то это означает, что мы нашли кратчайший цикл, и останавливаем обход в ширину; среди всех таких найденных циклов (по одному от каждого запуска обхода) выбираем кратчайший.</h3></li>
        <li><h3>Найти все рёбра, лежащие на каком-либо кратчайшем пути между заданной парой вершин (a,b). Для этого надо запустить 2 поиска в ширину: из a, и из b. Обозначим через d_a[] массив кратчайших расстояний, полученный в результате первого обхода, а через d_b[] — в результате второго обхода. Теперь для любого ребра (u,v) легко проверить, лежит ли он на каком-либо кратчайшем пути: критерием будет условие d_a[u] + 1 + d_b[v] = d_a[b].</h3></li>
        <li><h3>Найти все вершины, лежащие на каком-либо кратчайшем пути между заданной парой вершин (a,b). Для этого надо запустить 2 поиска в ширину: из a, и из b. Обозначим через d_a[] массив кратчайших расстояний, полученный в результате первого обхода, а через d_b[] — в результате второго обхода. Теперь для любой вершины v легко проверить, лежит ли он на каком-либо кратчайшем пути: критерием будет условие d_a[v] + d_b[v] = d_a[b].</h3></li>
        <li><h3>Найти кратчайший чётный путь в графе (т.е. путь чётной длины). Для этого надо построить вспомогательный граф, вершинами которого будут состояния (v,c), где v — номер текущей вершины, c = 0...1 — текущая чётность. Любое ребро (a,b) исходного графа в этом новом графе превратится в два ребра ((u,0),(v,1)) и ((u,1),(v,0)). После этого на этом графе надо обходом в ширину найти кратчайший путь из стартовой вершины в конечную, с чётностью, равной 0.</h3></li>
    </ul>
    <h1 >Реализация</h1>
    <p>Реализуем вышеописанный алгоритм на языке C++.</p>
    <p>Входные данные:</p>
    <pre>
            vector &lt; vector&lt;int&gt; &gt; g; // граф
            int n; // число вершин
            int s; // стартовая вершина (вершины везде нумеруются с нуля)

            // чтение графа
            ...
        </pre>
    <p>Сам обход:</p>
    <pre>
            queue&lt;int&gt; q;
            q.push (s);
            vector&lt;bool&gt; used (n);
            vector&lt;int&gt; d (n), p (n);
            used[s] = true;
            p[s] = -1;
            while (!q.empty()) {
                int v = q.front();
                q.pop();
                for (size_t i=0; i&lt;g[v].size(); ++i) {
                    int to = g[v][i];
                    if (!used[to]) {
                        used[to] = true;
                        q.push (to);
                        d[to] = d[v] + 1;
                        p[to] = v;
                    }
                }
            }
        </pre>
    <p>Если теперь надо восстановить и вывести кратчайший путь до какой-то вершины  to, это можно сделать следующим образом:</p>
    <pre>
            if (!used[to])
                cout &lt;&lt; "No path!";
            else {
                vector&lt;int&gt; path;
                for (int v=to; v!=-1; v=p[v])
                    path.push_back (v);
                reverse (path.begin(), path.end());
                cout &lt;&lt; "Path: ";
                for (size_t i=0; i&lt;path.size(); ++i)
                    cout &lt;&lt; path[i] + 1 &lt;&lt; " ";
            }
        </pre>
    <img src="res/bfs.gif">
</main>



<footer>
    <p>© 2018 My Project, nXXL</p>
</footer>

<link href="css/reset.css" rel="stylesheet">
<link href="css/style.css" rel="stylesheet">
<link href="/new/storage/fonts.css" rel="stylesheet">
<script src="/new/storage/js/main.js" ></script>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>

<script>
        $(window).scroll(function() {
            if ($(this).scrollTop() > 1){
                $('header').addClass("sticky");
            }
            else{
                $('header').removeClass("sticky");
            }
        });
        </script>
</body>
</html>